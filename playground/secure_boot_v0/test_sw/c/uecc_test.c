#include <stdint.h>
#include <stdbool.h>

#include "./utils/uart.h"
#include "./utils/micro-ecc/uECC.h"

static void uart_puts(const char *s) {
  while (*s) {
    uart_putc(*s++);
  }
}

static void uart_put_hex8(uint8_t v) {
  const uint8_t hi = (v >> 4) & 0xF;
  const uint8_t lo = v & 0xF;
  uart_putc((hi < 10) ? ('0' + hi) : ('A' + (hi - 10)));
  uart_putc((lo < 10) ? ('0' + lo) : ('A' + (lo - 10)));
}

static void uart_put_bytes(const uint8_t *buf, unsigned len) {
  for (unsigned i = 0; i < len; ++i) {
    uart_put_hex8(buf[i]);
  }
}

static void die(const char *msg) {
  uart_puts("FAIL: ");
  uart_puts(msg);
  uart_putc('\n');
  while (1) {
    __asm__ volatile("wfi");
  }
}

static uint32_t rng_state = 0x1u;

static uint32_t xorshift32(void) {
  uint32_t x = rng_state;
  x ^= x << 13;
  x ^= x >> 17;
  x ^= x << 5;
  rng_state = x;
  return x;
}

// Deterministic RNG for micro-ecc (good enough for self-test only)
static int uecc_rng(uint8_t *dest, unsigned size) {
  for (unsigned i = 0; i < size; ++i) {
    dest[i] = (uint8_t)(xorshift32() & 0xFF);
  }
  return 1;  // success
}

int main(void) {
  const struct uECC_Curve_t *curve = uECC_secp160r1();

  // Known-good test vector (secp160r1, message = 0x01..0x20)
  static const uint8_t pub[40] = {
    0x42,0xE2,0xA8,0x0A,0xC8,0x8D,0xFB,0x6C,
    0x42,0x41,0x43,0x3F,0xF4,0xB7,0x5A,0x8E,
    0x4A,0xDB,0xDC,0xB6,0x42,0x43,0xAE,0x1C,
    0x2A,0x3F,0x70,0xD1,0x4A,0xFB,0x60,0x34,
    0x19,0x53,0xA5,0x7D,0x42,0x88,0x89,0xC9,
  };

  static const uint8_t msg[32] = {
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
    0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
    0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,
  };

  // r||s signature for the above msg with the above pubkey (P-160)
  static const uint8_t sig[40] = {
    0xF8,0x1D,0xCA,0x9D,0xD4,0x94,0xB4,0x64,
    0x9A,0x42,0xD4,0xB5,0x35,0xB1,0xB8,0xA8,
    0x69,0x42,0x5D,0xF3,0x62,0x40,0xB3,0x94,
    0x3A,0xBF,0xBF,0xDC,0xEB,0x33,0xEC,0xAE,
    0xC4,0xED,0x6B,0x5F,0xDA,0x63,0xB7,0x4D,
  };

  uart_putc('s');

  if (!uECC_verify(pub, msg, sizeof(msg), sig, curve)) {
    die("verify");
  }

  uart_putc('V');

  while (1) {
    __asm__ volatile("wfi");
  }
}
